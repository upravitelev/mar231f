# SQL advanced {-}

```{r load-packages, include = FALSE}
pkgs <- c('data.table', 'RPostgreSQL')
for (pkg in pkgs) require(pkg, character.only = TRUE, quietly = TRUE, warn.conflicts = FALSE)

con <- dbConnect(PostgreSQL(max.con = 100),
                     user = "student",
                     password = "pmsar2018",
                     dbname = "pmsar",
                     host = "188.225.77.95",
                     port = 5432)
```

## Запись занятия {-}

<iframe width="560" height="315" src="https://www.youtube.com/embed/s7zZc-F3ENQ?si=Y3fpPBF71MqjmPJB" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

## Части SQL {-}

### Data Definition Language {-}

Набор команд для работы с объектами базы данных. С помощью этих команд можно создать, удалить или изменить какой-нибудь объект: таблицу, схему, функцию и т. д. Как правило для этих команд требуются дополнительные права пользователей.

CREATE – для создания объектов базы данных
ALTER – для изменения объектов базы данных
DROP – для удаления объектов базы данных

### Data Manipulation Language {-}

Набор команд для работы с данными - выбор данных (из таблицы или таблиц), добавление или изменение данных, удаление данных (обычно строк из таблицы, сама таблица при этом остается на месте - для ее удаления нужно сделать DROP TABLE).

SELECT – выборка данных
INSERT – добавляет новые данные
UPDATE – изменяет существующие данные
DELETE – удаляет данные

### Data Control Language {-}

Организация и контроль над доступом к базе данных. Например, службе дашборда надо выдать права на чтение данных.

GRANT – предоставляет пользователю или группе разрешения на определённые операции с объектом
REVOKE – отзывает выданные разрешения
DENY – задаёт запрет, имеющий приоритет над разрешением

### Transaction Control Language {-}

Команды для работы с транзакциями (группами запросов, которые выполняются пакетно, чтобы не было неконсистетности в данных). Обычно аналитики с такими задачами не сталкиваются.

BEGIN – служит для определения начала транзакции
COMMIT – применяет транзакцию
ROLLBACK – откатывает все изменения, сделанные в контексте текущей транзакции
SAVEPOINT – устанавливает промежуточную точку сохранения внутри транзакции

## data types {-}

### list {-}

В PostgreSQL (как и в других диалектах) есть большой набор разных типов данных, от стандартных (целые числа, с дробной частью, с плавающей точкой, строки, даты) до экзотических типа ip-адресов. Подробный список типов можно посмотреть вот здесь: [8. Data Types](https://www.postgresql.org/docs/current/sql.html): 

8.1. Numeric Types
8.2. Monetary Types
8.3. Character Types
8.4. Binary Data Types
8.5. Date/Time Types
8.6. Boolean Type
8.7. Enumerated Types
8.8. Geometric Types
8.9. Network Address Types
8.10. Bit String Types
8.11. Text Search Types
8.12. UUID Type
8.13. XML Type
8.14. JSON Types
8.15. Arrays
8.16. Composite Types
8.17. Range Types
8.18. Domain Types
8.19. Object Identifier Types
8.20. pg_lsn Type
8.21. Pseudo-Types

### Numeric types {-}

При работе с числовыми типами надо помнить о такой особенности, что целые числа и числа с дробью - это разные типы. И, например, при делении целого числа на целое SQL вернет также целое число (в R будет неявное преобращование типа):

```{sql  connection=con}
select 1 / 7, 7 / 3
```

Один из самых простых вариантов явного преобразования - умножить целое число с типом numeric (то есть, на 1.000):
```{sql  connection=con}
select 1 * 1.000 / 7
```

### Character Types {-}

Строковые типы, такие же как и в других языках программирования.

```{sql  connection=con}
select 'abc'
```

Из полезных функций - конкатенация (слияние строк, аналог `paste0()` в R) и изменение регистра.
```{sql  connection=con}
select 'a' || 'b', upper('abc'), lower('ABC')
```

Для работы со строковыми данными есть большая группа функций, использующих регулярные выражения. Вообще, регулярные выражения - весьма часто встречающаяся в жизни аналитиков вещь и их стоит освоить.

### Date/Time Types  {-}

Даты и время. Несмотря на то, что для для людей более читабельны даты и время в ISO-представлении ('гггг-мм-дд чч:мм:сс'), лучше использовать unix-timestamp -- представление даты в виде количества секнуд с 1970-01-01. Это представление проще, удобнее для хранения, не зависит от таймзоны пользователя и базы данных.

```{sql  connection=con}
--текущая дата
select current_date
```

Для преобразования даты в unix-timestamp используют функцию `extract()` с указанием, что извлекается `epoch`.
```{sql  connection=con}
select extract(epoch from current_date)
```

Обратное преобразование с помощью `to_timestamp()`:
```{sql  connection=con}
select to_timestamp(1636156800)
```

Даты вычитать достаточно просто, date - date. Но если надо из даты вычесть количество дней / месяцев / лет (или другой интервал), то можно воспользоваться следующей конструкцией:
```{sql  connection=con}
select current_date - interval '1' day
```

### type Conversion  {-}

Для преобразования типов в Postgresql обычно используют `::`, также есть более классическая и распространенная во всех диалектах функция `cast()`:

```{sql  connection=con}
select 
  1 * 1.000 / 7, 
  1 :: numeric / 7,
  cast(1 as numeric) / 7
```

## values {-}

Иногда бывают ситуации, когда надо создать таблицу в запросе - для этого можно с помощью команды values вычислить набор строк, в которых заданы значения (количество значений в строках должно быть одинаковыми). Названия колонок в создаваемой таблице можно задать с помощью as tablename(col1_name, col2_name...), по количеству создаваемых колонок.

```{sql  connection=con}
select 
	* 
from (
	values 
		(1, 'a', 'grp1'),
		(2, 'b', 'grp1')
) as tbl(var1, var2, var3)
```

## subquery {-}

Нередко в запросах надо обратиться к подвыборке из другой таблицы. Например, это может быть как в разделе join:

```{sql  connection=con}
select 
	* 
-- создаем и обращаемся к первой таблице
from (
	values 
		(1, 'a', 'grp1'),
		(2, 'b', 'grp1')
) as tbl(var1, var2, var3)
-- создаем и джойним вторую таблицу
left join (
  select * from (
    values 
		('2021-11-06', 'grp1')      
  ) as tb2(var4, var3)
) as t2 using(var3)
```

Более простой пример с уже существующими таблицами:
```{sql connection=con}
select
	*
from chars
left join (
	select planet_name, gravity
	from planets
	where climate = 'temperate'
) as p using(planet_name)
```

Также вложенные запросы могут быть в блоке `where`:
```{sql connection=con}
select
	*
from chars
where planet_name in (
	select planet_name from planets where climate = 'temperate'
)
```


## Common tables expressions {-}

Общие таблицы или "выражения с with" -- крайне полезный инструмент, так как позволяет создавать в запросе временные таблицы (которые живут только во время запроса и нигде не созраняются) и обращаться к этим таблицам во время запроса.

Для экспериментов удобно совмещать создание таблиц из заданных значений с помощью values и операции с этими таблицами с помощью with:
```{sql connection = con}
-- указываем, что таблицы из запросов ниже будут временными и общими для всего запроса
with 
  -- создаем первую таблицу
	tmp1 as (
		select 
			* 
		from (
			values 
				(1, 'a', 'grp1'),
				(2, 'b', 'grp1')
		) as tbl(var1, var2, var3)
	),
	-- создаем вторую таблицу
	tmp2 as (
    select * from (
      values 
  		('2021-11-06', 'grp1')      
    ) as tb2(var4, var3)
	)
	
--основная часть - пишем запрос к созданным таблицам
select * 
from tmp1
left join tmp2 using(var3)
```


## select experiments {-}

### functions {-}

В блоке select можно использовать разные, временами сложные конструкции. Самое простое - какая-то операция с колонкой, например, вычисление среднего (для среднего в sql-диалектах используется функция `avg()`) или максимума. 

```{sql  connection=con}
with 
	tmp as (
		select * 
		from (
			values 
				(1, 'a', 'grp1'),
				(2, 'b', 'grp1')
		) as tbl(v1, v2, v3)
	)
select
	count(*) as n_rows,
	count(distinct v3) as n_groups,
	avg(v1) as v2_avg
from tmp
```


### case {-}

Немного более сложный, но очень полезный инструмент - оператор логического ветвления. В R это аналог switch или вложенных ifelse. 

```{sql  connection=con}
with 
	tmp as (
		select * 
		from (
			values 
				(1, 'a', 'grp1'),
				(2, 'b', 'grp1'),
				(3, NULL, 'grp1'),
				(4, 'd', 'grp2'),
				(5, 'e', 'grp2')
		) as tbl(v1, v2, v3)
	)
select
	*,
	-- открываем логическое ветвление
	case 
	  -- первое условие
		when v1 < 3 then 'g1'
		-- второе условие
		when v1 = 3 then 'g2'
		-- третье условие - "все прочее"
		else 'g3'
	-- закрываем ветвление и указываем, как назвать колонку
	end as grp2
from tmp
```

### filter {-}

Полезная, но достаточно малоизвестная конструкция - значения в колонках можно фильтровать по значениям других колонок. 

```{sql  connection=con}
with 
	tmp as (
		select * 
		from (
			values 
				(1, 'a', 'grp1'),
				(2, 'b', 'grp1'),
				(3, NULL, 'grp1'),
				(4, 'd', 'grp2'),
				(5, 'e', 'grp2')
		) as tbl(v1, v2, v3)
	)
select
  -- считаем количество строк, в которых в v3 есть значение grp1
	count(*) filter(where v3 = 'grp1'),
	-- одновременно считаем количество значений в колонке v1, для которых в v3 есть значение grp2
	count(v1) filter(where v3 = 'grp2')
from tmp
```

## Window functions {-}

### row_number() over () {-}

Select-запросы в SQL предназначены в первую очередь для извлечения подвыборок (из одной или нескольких таблиц, с определенным составом колонок). Поэтому какие-то более сложные операции бывает достаточно сложно сделать. Одними из таких операций являются действия с колонками, в которых учитываются значения колонки в предыдущих строках - например, кумулятивная сумма или сумма в определенном окне (количестве строк до текущей) и тому подобные.

Такие операции делаются в SQL с помощью оконных функций, где под окном понимается определенный набор строк колонки, с которыми надо выполнить какие-то операции. Один из самых простых видов оконных функций - нумерация строк:

```{sql  connection=con}
with 
	tmp as (
		select * 
		from (
			values 
				(1, 'a', 'grp1'),
				(2, 'b', 'grp1'),
				(3, NULL, 'grp1'),
				(4, 'd', 'grp2'),
				(5, 'e', 'grp2')
		) as tbl(v1, v2, v3)
	)
select
	*,
	-- row_number() - функция определения номера, over() - определение окна. 
	-- так как в over() ничего не указано, под окном понимаются все строки таблицы
	row_number() over() as counter
from tmp
```

### over (partition by) {-}

Оконные операции можно выполнять в группах по значениям какой-то колонки, так же при этом можно сортировать строки по другим колонкам:
```{sql  connection=con}
with 
	tmp as (
		select * 
		from (
			values 
				(1, 'a', 'grp1'),
				(2, 'b', 'grp1'),
				(3, NULL, 'grp1'),
				(4, 'd', 'grp2'),
				(5, 'e', 'grp2')
		) as tbl(v1, v2, v3)
	)
select
	*,
	-- указываем, что окно бьется на группы в зависимости от значений v3
	row_number() over(partition by v3) as counter,
	-- указываем, что окно бьется на группы в зависимости от значений v3
	-- и одновременно сортируем значения по убыванию в зависимости от колонки v1
	row_number() over(partition by v3 order by v1 desc) as counter_rev
from tmp
order by v1
```

### total sum {-}

Другой пример запроса с оконной функцией -- считаем общую сумму по колонке по всей таблице и записываем ее в отдельную колонку (значение суммы одно, просто размножается по количеству строк).

```{sql  connection=con}
with 
	tmp as (
		select * 
		from (
			values 
				(1, 'a', 'grp1'),
				(2, 'b', 'grp1'),
				(3, NULL, 'grp1'),
				(4, 'd', 'grp2'),
				(5, 'e', 'grp2')
		) as tbl(v1, v2, v3)
	)
select
	*,
	-- считаем сумму v1 по всем строкам таблицы
	sum(v1) over() as total_sum
from tmp
```


### cumulative sum {-}

Более сложная конструкция для вычисления кумулятивной суммы. Здесь мы указываем, что хотим посчитать не просто сумму, а кумулятивную сумму. Кумулятивная сумма представляется как сумма всех значений колонки от начала и до текущей строки -- окно, в котором считается сумма, с каждой строкой расширяется. Такое поведение задается аргументом range, в котором указывем границы (можно и другие границы указать):

```{sql  connection=con}
with 
	tmp as (
		select * 
		from (
			values 
				(1, 'a', 'grp1'),
				(2, 'b', 'grp1'),
				(3, NULL, 'grp1'),
				(4, 'd', 'grp2'),
				(5, 'e', 'grp2')
		) as tbl(v1, v2, v3)
	)
select
	*,
	-- для каждой строки считаем сумму v1 от начала до текущей строки
	sum(v1) over(order by v1 range between unbounded preceding and current row) as cum_sum
from tmp
```

## explain {-}

### plan {-}

Для оптимизации можно посмотреть план запроса, который составляет оптимизатор. Умение читать и интерпретировать подобные планы приходит с опытом, чем больше - тем лучше, я не настолько хорошо знаю эту область, чтобы полноценно про нее рассказывать. Здесь просто для иллюстрации, что такое вообще есть.

```{sql  connection=con}
explain
	select * 
	from chars
	where planet_name = 'Naboo'
```

### analyze {-}

Когда мы явно указываем `analyze`, оптимизатор не просто создает план запроса, а реально выполняет запрос и выводит, сколько времени потребовалось выполнение того или иного этапа запроса.

```{sql  connection=con}
explain analyze
	select * 
	from chars
	where planet_name = 'Naboo'
```




